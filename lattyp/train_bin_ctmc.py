#!/bin/env python
# -*- coding: utf-8 -*-
#
# posterior inference of a CTMC-based phylogenetic model
#
import sys
import os
import re
from pickle import load, dump
from argparse import ArgumentParser
import numpy as np
import random

from json_utils import load_json_file, load_json_stream
from phylo import CTMC_Sampler
from rand_utils import rand_partition_log, slice_sampler1d
from priors import create_node_priors

def attach_sample(trees, langs, node_priors, latent=True, has_bias=False, max_states=-1):
    # id: glottocode:name as a glottocode can be shared by two or more WALS/autotyp languages
    idx2id = {}
    for i, lang in enumerate(langs):
        if "glottocode" in lang:
            idx2id[i] = lang["glottocode"] + ":" + lang["annotation"]["name"]
    id2node = {}
    glottocode2node = {}
    for tree in trees:
        register_node(tree, id2node, glottocode2node)

    # attach priors
    if node_priors is not None:
        for glottocode, prior in node_priors.items():
            if glottocode in glottocode2node:
                node = glottocode2node[glottocode]
                node.prior = prior
            else:
                sys.stderr.write("glottocode ({}) not found; skip the specified prior\n".format(glottocode))


    # TODO: attach updated note to tree

    # if merged:
    # a list of languages generated by convert_auto_xz.py
    states = None
    offset = 1 if has_bias else 0
    for i, lang in enumerate(langs):
        if i in idx2id:
            _id = idx2id[i]
            if _id in id2node:
                node = id2node[_id]
                if latent:
                    thres = lang["count"] / 2
                    node.state = np.array(lang["zfreq"][offset:], dtype=np.int32) >= thres
                else:
                    node.state = np.array(lang["catvect_filled"], dtype=np.int32)
                    if states is None:
                        states = np.zeros(len(lang["catvect_filled"]), dtype=np.int32)
                    for k, v in enumerate(lang["catvect_filled"]):
                        states[k] = max(states[k], v + 1)
    if latent:
        return node.state.size, 2
    else:
        if max_states > 0:
            cond = states <= max_states
            sys.stderr.write("filtering by max. num. of states: {} -> {}\n".format(len(states), cond.sum()))
            for i, lang in enumerate(langs):
                if i in idx2id:
                    _id = idx2id[i]
                    if _id in id2node:
                        node = id2node[_id]
                        node.state = np.extract(cond, node.state)
        states = np.extract(cond, states)
        return node.state.size, states
    # else:
    #     assert(latent == True) # UNDER CONSTRUCTION

    #     # a model sample
    #     z = np.array(sample["z"], dtype=np.bool_).T
    #     for idx, state in enumerate(z):
    #         if idx in idx2id:
    #             _id = idx2id[idx]
    #             if _id in id2node:
    #                 node = id2node[_id]
    #                 node.state = state
    #     return z.shape[1]

def register_node(node, id2node, glottocode2node):
    if hasattr(node, "lang"):
        assert("glottocode" in node.lang)
        _id = node.lang["glottocode"] + ":" + node.lang["annotation"]["name"]
        assert(_id not in id2node)
        id2node[_id] = node
    if hasattr(node, "glottocode"):
        glottocode2node[node.glottocode] = node
    if len(node.children) <= 0:
        assert(hasattr(node, "lang"))
    for child in node.children:
        register_node(child, id2node, glottocode2node)

def main():
    parser = ArgumentParser()
    parser.add_argument("-s", "--seed", dest="seed", metavar="INT", type=int, default=None,
                        help="random seed")
    # parser.add_argument("--sidx", metavar="IDX", type=int, default=0,
    #                     help="i-th sample of leaf states (-1: last sample)")
    parser.add_argument("--npriors", metavar="NODE_PRIORS", default=None, help="priors for nodes (json)")
    parser.add_argument("-i", "--iter", dest="_iter", metavar="INT", type=int, default=1000,
                        help="# of iterations")
    parser.add_argument("--resume_if", action="store_true", default=False,
                        help="resume training if the output exists")
    parser.add_argument("--resume", metavar="FILE", default=None,
                        help="resume training from model dump")
    parser.add_argument("--save_interval", metavar="INT", type=int, default=-1,
                        help="save interval")
    # parser.add_argument("--merged", action="store_true", default=False,
    #                     help="use merged langs instead of a single sample")
    parser.add_argument("--has_bias", action="store_true", default=False,
                        help="0th item of z is a bias term (always 1)")
    parser.add_argument("--surface", dest="latent", action="store_false", default=True,
                        help="use surface features")
    parser.add_argument("--surface_state_limit", dest="max_states", type=int, default=-1,
                        help="maximum number of distinct states of surface features (trimming for speed)")
    parser.add_argument("trees", metavar="TREES", default=None, help="merged trees (pkl)")
    parser.add_argument("langs", metavar="LANG", default=None)
    # parser.add_argument("samples", metavar="SAMPLES", default=None, help="parameter states (json stream)")
    parser.add_argument("out", metavar="OUT", default=None, help="out (pkl)")
    args = parser.parse_args()

    if args.seed is not None:
        np.random.seed(args.seed)
        random.seed(args.seed)

    if args.resume_if:
        if os.path.isfile(args.out + ".current"):
            args.resume = args.out + ".current"
        elif os.path.isfile(args.out + ".best"):
            args.resume = args.out + ".best"
    if args.resume:
        sys.stderr.write("loading model from %s\n" % args.resume)
        spec = load(open(args.resume, "rb"))
        trees = spec["trees"]
        sampler = spec["sampler"]
        if "logprob" not in spec:
            logprob = sampler.logprob(trees)
        else:
            logprob = spec["logprob"]
        sys.stderr.write("iter {}\t{}\n".format(spec["iter"], logprob))
        _start = spec["iter"] + 1
    else:
        _start = 1
        trees = load(open(args.trees, 'rb'))
        sys.stderr.write("{} trees\n".format(len(trees)))

        node_priors = None
        if args.npriors is not None:
            prior_specs = load_json_file(args.npriors)
            node_priors = create_node_priors(prior_specs)
    
        langs = list(load_json_stream(open(args.langs, "r")))
        # with open(args.samples, 'r') as f:
        #     if args.merged:
        #         sample = list(load_json_stream(f))
        #     else:
        #         for i, sample in enumerate(load_json_stream(f)):
        #             if i == args.sidx:
        #                 break
        K, states = attach_sample(trees, langs, node_priors, has_bias=args.has_bias, latent=args.latent, max_states=args.max_states)

        sampler = CTMC_Sampler(K, states=states, ctmc_scale=0.00005)
        sampler.init_trees(trees)
        sys.stderr.write("iter 0\t{}\n".format(sampler.logprob(trees)))

    _iter = _start - 1
    if args.save_interval >= 0 and _iter % args.save_interval == 0:
        with open(args.out + ".{}".format(_iter), "wb") as f:
            dump({ "sampler": sampler, "trees": trees, "iter": _iter, "logprob": logprob }, f)
    for _iter in range(_start, args._iter + 1):
        sampler.sample(_iter=_iter)
        logprob = sampler.logprob(trees)
        sys.stderr.write("iter {}\t{}\n".format(_iter, logprob))
        if args.save_interval >= 0 and _iter % args.save_interval == 0:
            with open(args.out + ".{}".format(_iter), "wb") as f:
                dump({ "sampler": sampler, "trees": trees, "iter": _iter, "logprob": logprob }, f)
        with open(args.out + ".current", "wb") as f:
            dump({ "sampler": sampler, "trees": trees, "iter": _iter, "logprob": logprob }, f)
    with open(args.out + ".final", "wb") as f:
        dump({ "sampler": sampler, "trees": trees, "iter": _iter, "logprob": logprob }, f)

if __name__ == "__main__":
    main()
